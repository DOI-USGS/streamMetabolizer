% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calc_DO_mod.R, R/calc_DO_mod_by_diff.R, R/calc_DO_mod_w_fixed_error.R, R/calc_DO_mod_w_sim_error.R
\name{calc_DO_mod}
\alias{calc_DO_mod}
\alias{calc_DO_mod_by_diff}
\alias{calc_DO_mod_w_fixed_error}
\alias{calc_DO_mod_w_sim_error}
\title{Calculate a time series of DO concentrations from GPP, ER, K600, and other
inputs}
\usage{
calc_DO_mod(GPP.daily, ER.daily, K600.daily, DO.sat, depth, temp.water,
  frac.GPP, frac.ER, frac.D, DO.mod.1, n, ODE_method = "pairmeans", ...)

calc_DO_mod_by_diff(GPP.daily, ER.daily, K600.daily, DO.obs, DO.sat, depth,
  temp.water, frac.GPP, frac.ER, frac.D, n, ODE_method = c("pairmeans",
  "Euler"), ...)

calc_DO_mod_w_fixed_error(GPP.daily, ER.daily, K600.daily, DO.sat, depth,
  temp.water, frac.GPP, frac.ER, frac.D, DO.mod.1, n, err.obs = rep(0, n),
  err.proc = rep(0, n), ODE_method = c("pairmeans", "Euler"), ...)

calc_DO_mod_w_sim_error(GPP.daily, ER.daily, K600.daily, DO.sat, depth,
  temp.water, frac.GPP, frac.ER, frac.D, DO.mod.1, n, err.obs.sigma,
  err.obs.phi, err.proc.sigma, err.proc.phi, ODE_method = "pairmeans", ...)
}
\arguments{
\item{GPP.daily}{One GPP rate per day (mg O2 / L / d)}

\item{ER.daily}{One ER rate per day (mg O2 / L / d), always non-positive.}

\item{K600.daily}{One K600 per day (1 / d)}

\item{DO.sat}{dissolved oxygen concentrations if the water were at 
equilibrium saturation \eqn{mg O[2] L^{-1}}{mg O2 / L}. Calculate using 
\link{calc_DO_at_sat}}

\item{depth}{stream depth, \eqn{m}{m}.}

\item{temp.water}{stream temperature in degC}

\item{frac.GPP}{the fraction of daily GPP to apply to each timestep}

\item{frac.ER}{the fraction of daily ER to apply to each timestep}

\item{frac.D}{the fraction of daily D to apply to each timestep}

\item{DO.mod.1}{the first DO.obs value, to which the first DO.mod value will 
be set}

\item{n}{number of DO.mod values to produce}

\item{ODE_method}{character specifying the numerical integration method to 
use. The default is pairmeans, where the change in DO between times t-1 and
t is a function of the mean DO.sat between times t-1 and t, mean temp.water
between times t-1 and t, mean light between times t-1 and t, etc. The Euler
method is currently more common in the literature, with each time step 
depending entirely on DO.sat, GPP, etc. at time t. Both methods are
imprecise and fast, relative to Runge-Kutta or other numerical integration
methods}

\item{...}{additional arguments passed to other variants on calc_DO_mod}

\item{DO.obs}{a vector of observed DO, from which values at time t will be 
used to model values at time t+1}

\item{err.obs}{A vector of observation errors of length n. Observation errors
are those applied to DO.mod after generating the full time series of 
modeled values.}

\item{err.proc}{A vector process errors of length n. Process errors are 
applied at each time step, and therefore propagate into the next timestep.}

\item{err.obs.sigma}{The sd of observation error, or 0 for no observation 
error. Observation errors are those applied to DO.mod after generating the 
full time series of modeled values.}

\item{err.obs.phi}{The autocorrelation coefficient of the observation errors,
or 0 for uncorrelated errors.}

\item{err.proc.sigma}{The sd of process error, or 0 for no process error. 
Process errors are applied at each time step, and therefore propagate into 
the next timestep.}

\item{err.proc.phi}{The autocorrelation coefficient of the process errors, or
0 for uncorrelated errors.}
}
\description{
\code{calc_DO_mod} simulates DO with no observation or process error.

\code{calc_DO_mod_by_diff} simulates DO using a process error model, i.e., 
AKA one-step-ahead prediction. In this model, DO.mod[t] is a function of 
DO.obs[t-1], so each DO.mod value essentially describes only the processes 
occurring between times t-1 and t. The difference between DO.mod[t] and 
DO.obs[t] can therefore be interpreted as error in the process estimate (as a
rate of mg/L per timestep)

\code{calc_DO_mod_w_fixed_error} simulates DO with vectors of observation 
and/or process error.

#' \code{calc_DO_mod_w_sim_error} simulates DO with new, randomly generated
vectors of observation and/or process error each time
}
\details{
Accepts GPP, ER, etc. and returns DO.mod. Used in many functions, including 
metab_mle() and predict_DO.metab_mle()
}
\examples{
n = 24
DO <- calc_DO_mod(GPP.daily=3, ER.daily=-9, K600.daily=2.5, 
  DO.sat=11, depth=1, temp.water=rep(12,n), 
  frac.GPP=with(data.frame(sinpow=sin(seq(0,pi,length.out=n))^4), sinpow/sum(sinpow)), 
  frac.ER=rep(1/n,n), frac.D=rep(1/n,n), 
  DO.mod.1=8, n=n, ODE_method="Euler")
\dontrun{
plot(DO)
}
fr <- rep(1/48,48) # shorthand for readability of next lines
gfr <- sin((1:48)/(4*pi))^8; gfr <- gfr/sum(gfr)
do <- 2*sin((1:48 - 10)/(4*pi))^4 + 10
domod_pm <- calc_DO_mod_by_diff(10, -13, 2.5, do, 14, 1, rep(12,48), gfr, fr, fr, 48, "pairmeans")
domod_eu <- calc_DO_mod_by_diff(10, -13, 2.5, do, 14, 1, rep(12,48), gfr, fr, fr, 48, "Euler")
\dontrun{
plot(domod_eu)
points(domod_pm, col='red')
}
fr <- rep(1/48,48) # shorthand for readability of next lines
gfr <- sin((1:48)/(4*pi))^8; gfr <- gfr/sum(gfr)
obsrnorm <- stats::rnorm(48,0,0.4)
procrnorm <- stats::rnorm(48,0,0.2)
preds <- lapply(c("Euler","pairmeans"), function(method) {
 data.frame(
  t=1:48,
  method=method,
  no_err = calc_DO_mod_w_fixed_error(
   10, -13, 2.5, 14, 1, rep(12,48), gfr, fr, fr, 11, 48, 0, 0, method),
  obs_err_const = calc_DO_mod_w_fixed_error(
   10, -13, 2.5, 14, 1, rep(12,48), gfr, fr, fr, 11, 48, 0.1, 0, method),
  obs_err_rnorm = calc_DO_mod_w_fixed_error(
   10, -13, 2.5, 14, 1, rep(12,48), gfr, fr, fr, 11, 48, obsrnorm, 0, method),
  proc_err_const = calc_DO_mod_w_fixed_error(
   10, -13, 2.5, 14, 1, rep(12,48), gfr, fr, fr, 11, 48, 0, 0.01, method),
  proc_err_rnorm = calc_DO_mod_w_fixed_error(
   10, -13, 2.5, 14, 1, rep(12,48), gfr, fr, fr, 11, 48, 0, procrnorm, method),
  all_err = calc_DO_mod_w_fixed_error(
   10, -13, 2.5, 14, 1, rep(12,48), gfr, fr, fr, 11, 48, 
   obsrnorm, procrnorm, method),
  stringsAsFactors=FALSE
 )
})
\dontrun{
library(ggplot2); library(tidyr); library(dplyr)
ggplot(gather(bind_rows(preds), type, value, no_err, obs_err_const, obs_err_rnorm, 
              proc_err_const, proc_err_rnorm, all_err), 
  aes(x=t, y=value, color=type)) + geom_line(aes(linetype=method)) + theme_bw() +
  facet_wrap(~ type)
ggplot(preds \%>\% bind_rows \%>\% 
  mutate(perfect = rep(no_err[method=="pairmeans"], times=2)) \%>\%
  gather(type, value, no_err, obs_err_const, obs_err_rnorm, 
         proc_err_const, proc_err_rnorm, all_err), 
  aes(x=t, y=value-perfect, color=type)) + geom_line(aes(linetype=method)) + 
  theme_bw() + facet_wrap(~ type)
}
fr <- rep(1/100,100) # shorthand for readability of next lines
preds <- data.frame(
 t=1:100,
 no_err = calc_DO_mod_w_sim_error(
  10, -13, 2.5, 14, 1, rep(12,100), fr, fr, fr, 11, 100, 0, 0, 0, 0),
 obs_err = calc_DO_mod_w_sim_error(
  10, -13, 2.5, 14, 1, rep(12,100), fr, fr, fr, 11, 100, 0.1, 0, 0, 0),
 ac_obs_err = calc_DO_mod_w_sim_error(
  10, -13, 2.5, 14, 1, rep(12,100), fr, fr, fr, 11, 100, 0.1, 0.6, 0, 0),
 proc_err = calc_DO_mod_w_sim_error(
  10, -13, 2.5, 14, 1, rep(12,100), fr, fr, fr, 11, 100, 0, 0, 0.03, 0),
 ac_proc_err = calc_DO_mod_w_sim_error(
  10, -13, 2.5, 14, 1, rep(12,100), fr, fr, fr, 11, 100, 0, 0, 0.03, 0.6),
 all_err = calc_DO_mod_w_sim_error(
  10, -13, 2.5, 14, 1, rep(12,100), fr, fr, fr, 11, 100, 0.1, 0.6, 0.03, 0.6)
)
all(preds$no_err == calc_DO_mod(10, -13, 2.5, 14, 1, rep(12,100), 
  rep(1/100,100), rep(1/100,100), rep(1/100,100), 11, 100))
\dontrun{
library(ggplot2); library(tidyr)
ggplot(gather(preds, type, value, no_err, obs_err, ac_obs_err), 
  aes(x=t, y=value, color=type)) + geom_line() + theme_bw()
ggplot(gather(preds, type, value, no_err, proc_err, ac_proc_err), 
  aes(x=t, y=value, color=type)) + geom_line() + theme_bw()
ggplot(gather(preds, type, value, no_err, all_err), 
  aes(x=t, y=value, color=type)) + geom_line() + theme_bw()
}
}

