% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/specs.R
\name{specs}
\alias{specs}
\title{Generate a coherent list of model specs}
\usage{
specs(model_name = mm_name(), engine, day_start = 4, day_end = 28,
  day_tests = c("full_day", "even_timesteps", "complete_data"),
  GPP_init = 10, ER_init = -10, K600_init = 10, calc_DO_fun, ODE_method,
  split_dates, keep_mcmcs = TRUE, GPP_daily_mu = 10, GPP_daily_sigma = 10,
  ER_daily_mu = -10, ER_daily_sigma = 10, K600_daily_mu = 10,
  K600_daily_sigma = 10, K600_daily_mu_mu = 10, K600_daily_mu_sigma = 10,
  K600_daily_beta_mu = c(intercept = 10, slope = 3),
  K600_daily_beta_sigma = c(intercept = 8, slope = 2),
  K600_daily_beta_num = 5, K600_daily_beta_cuts = "number",
  K600_daily_sigma_shape = 1, K600_daily_sigma_rate = 2,
  err_obs_iid_sigma_shape = 1, err_obs_iid_sigma_rate = 10,
  err_proc_acor_phi_shape = 1, err_proc_acor_phi_rate = 1000,
  err_proc_acor_sigma_shape = 1, err_proc_acor_sigma_rate = 1000,
  err_proc_iid_sigma_shape = 1, err_proc_iid_sigma_rate = 100,
  priors = FALSE, params_out, n_chains = 4, n_cores = 4,
  adapt_steps = switch(mm_parse_name(model_name)$engine, jags = 250, NA),
  burnin_steps = switch(mm_parse_name(model_name)$engine, stan = 500, jags =
  250, NA), saved_steps = switch(mm_parse_name(model_name)$engine, stan = 500,
  jags = 1000, NA), thin_steps = 1, verbose = FALSE,
  weights = c("K600/CI"), filters = c(CI.max = NA, discharge.daily.max = NA,
  velocity.daily.max = NA), predictors = c("discharge.daily"),
  transforms = c(K600 = "log", date = NA, velocity.daily = "log",
  discharge.daily = "log"), other_args = c(), err.obs.sigma = 0.1,
  err.obs.phi = 0, err.proc.sigma = 0, err.proc.phi = 0, sim.seed = NA)
}
\arguments{
\item{model_name}{character string identifying the model features. Use 
\code{\link{mm_name}} for valid names. This may be a full model file path 
for custom Bayesian models, as long as basename(model_name) can still be 
parsed correctly with \code{mm_parse_name()}. In that case the file may be 
specified either as a file path relative to the streamMetabolizer models 
directory (the first assumption; this directory can be found with 
\code{system.file("models", package="streamMetabolizer")}) or as an 
absolute path or a path relative to the current working directory (the 
second assumption, if the first assumption turns up no files of the given 
name).}

\item{engine}{The software or function to use in fitting the model. Should be
specified via \code{mm_name} rather than here. For type='bayes', one of 
\code{c('jags','stan')} indicating the software package to use for the MCMC
process. For type='Kmodel', the name of an interpolation or regression 
method relating K to the predictor[s] of choice. One of \code{c("mean", 
"lm", "loess")}. For types in \code{c('mle','night','sim')} there's only 
one option so it's not included in \code{specs()} (but is nonetheless noted
in the suffix of the model name, e.g., \code{"m_np_oi_pm_km.nlm"} uses 
\code{nlm()} for model fitting)}

\item{day_start}{start time (inclusive) of a day's data in number of hours 
from the midnight that begins the date. For example, day_start=-1.5 
indicates that data describing 2006-06-26 begin at 2006-06-25 22:30, or at 
the first observation time that occurs after that time if day_start doesn't
fall exactly on an observation time. For metabolism models working with 
single days of input data, it is conventional/useful to begin the day the 
evening before, e.g., -1.5, and to end just before the next sunrise, e.g., 
30. For multiple consecutive days, it may make the most sense to start just
before sunrise (e.g., 4) and to end 24 hours later. For nighttime 
regression, the date assigned to a chunk of data should be the date whose 
evening contains the data. The default is therefore 12 to 36 for 
metab_night, of which the times of darkness will be used.}

\item{day_end}{end time (exclusive) of a day's data in number of hours from 
the midnight that begins the date. For example, day_end=30 indicates that 
data describing 2006-06-26 end at the last observation time that occurs 
before 2006-06-27 06:00. See day_start for recommended start and end times.}

\item{day_tests}{list of tests to conduct to determine whether each date 
worth of data is valid for modeling. the results of these tests will be 
passed to \code{model_fun} as the \code{ply_validity} argument to that 
function.}

\item{GPP_init}{the inital value of daily GPP to use in the NLM fitting 
process}

\item{ER_init}{the inital value of daily ER to use in the NLM fitting process}

\item{K600_init}{the inital value of daily K600 to use in the NLM fitting 
process. Ignored if K600 is supplied in data_daily, except for those dates 
where K600 is NA. If there are any such dates, K600_init must have a 
numeric (non-NA) value, as this will be used to estimate K600 for those 
dates.}

\item{calc_DO_fun}{the function to use to build DO estimates from GPP, ER, 
etc. default is calc_DO_mod, but could also be calc_DO_mod_by_diff}

\item{ODE_method}{character specifying the numerical integration method to 
use. The default is pairmeans, where the change in DO between times t-1 and
t is a function of the mean DO.sat between times t-1 and t, mean temp.water
between times t-1 and t, mean light between times t-1 and t, etc. The Euler
method is currently more common in the literature, with each time step 
depending entirely on DO.sat, GPP, etc. at time t. Both methods are
imprecise and fast, relative to Runge-Kutta or other numerical integration
methods}

\item{split_dates}{logical indicating whether the data should be split into 
daily chunks first (TRUE) or processed within one big model (FALSE). If 
valid days differ in their timestep length, split_dates will need to be 
TRUE; otherwise, FALSE is generally more efficient. FALSE is also the only 
appropriate solution for a hierarchical model that pools information on 
error, K600, etc. across days.}

\item{keep_mcmcs}{TRUE, FALSE, or (for nopool models) a vector of dates 
(coerced with as.Date if character, etc.) indicating whether to keep all of
the mcmc model objects (TRUE), none of them (FALSE), or specific dates. The
default is FALSE because these objects can be very large.}

\item{GPP_daily_mu}{The mean of a dnorm distribution for GPP_daily, the daily
rate of gross primary production}

\item{GPP_daily_sigma}{The standard deviation of a dnorm distribution for 
GPP_daily, the daily rate of gross primary production}

\item{ER_daily_mu}{The mean of a dnorm distribution for ER_daily, the daily 
rate of ecosystem respiration}

\item{ER_daily_sigma}{The standard deviation of a dnorm distribution for 
ER_daily, the daily rate of ecosystem respiration}

\item{K600_daily_mu}{Applies when pool_K600 is 'none'. The mean of a dnorm 
distribution for K600_daily, the daily rate of reaeration}

\item{K600_daily_sigma}{Applies when pool_K600 is 'none'. The standard 
deviation of a dnorm distribution for K600_daily, the daily rate of 
reaeration}

\item{K600_daily_mu_mu}{hyperparameter for pool_K600='normal'. The mean 
parameter (mu_mu) of a normal distribution of mu in K ~ N(mu, sigma), mu ~ 
N(mu_mu, mu_sigma)}

\item{K600_daily_mu_sigma}{hyperparameter for pool_K600='normal'. The 
standard deviation parameter (mu_sigma) of a normal distribution of mu in K
~ N(mu, sigma), mu ~ N(mu_mu, mu_sigma)}

\item{K600_daily_beta_mu}{hyperparameter for pool_K600 in 
c('linear','binned'). The means of prior distributions for the 
K600_daily_beta paramters. For pool_K600='linear', there are 2 betas 
corresponding to the intercept and slope, respectively, of the linear model
\code{log(K600) ~ K600_daily_beta[1] + K600_daily_beta[2]*log(Q)}. For 
pool_K600='binned', there are K600_daily_beta_num betas each giving the 
predicted K600 when Q_daily is in the corresponding bin (see 
\code{K600_daily_beta_cuts}).}

\item{K600_daily_beta_sigma}{hyperparameter for pool_K600='linear'. The 
standard deviation parameter of a normally distributed intercept term 
(beta0) in the linear model K ~ N(beta0 + beta1*log(Q)), beta0 ~ 
N(beta0_mu, beta0_sigma)}

\item{K600_daily_beta_num}{hyperparameter for pool_K600='binned'. The number 
of bins into which daily discharge values should be grouped. Each bin 
predicts a single value of K600_daily_pred, such that any day on which 
\code{discharge_bin_daily} equals that bin will have \code{K600_daily ~ 
N(K600_daily_beta[discharge_bin_daily], K600_daily_sigma)}}

\item{K600_daily_beta_cuts}{hyperparameter for pool_K600='binned'. Either (1)
character of length 1 in c('number','interval') indicating how the bin cuts
should be determined, or (2) numeric (as in \code{breaks} in 
\code{\link[base]{cut}}) of length K600_daily_beta_num+1 giving the 
natural-log-space breakpoints defining the bins. For option 1, the 
implementation uses or is equivalent to the corresponding functions 
\code{\link[ggplot2]{cut_interval}} (to cut into bins having equal numeric 
ranges in natural log space) and \code{\link[ggplot2]{cut_number}} (to cut 
into bins having ~equal numbers of ln_discharge_daily observations). For 
option 2, make sure to include the full range of ln_discharge_daily, with 
the first value smaller than all ln_discharge_daily values and the last 
value greater than or equal to all ln_discharge_daily values.}

\item{K600_daily_sigma_shape}{hyperparameter for pool_K600 in 
c('normal','linear','binned'). The shape (= alpha = k) parameter of a gamma
distribution of sigma in K ~ N(mu, sigma), sigma ~ gamma(shape, rate)}

\item{K600_daily_sigma_rate}{hyperparameter for pool_K600 in 
c('normal','linear','binned'). The rate (= beta = 1/theta = inverse scale) 
parameter of a gamma distribution of sigma in K ~ N(mu, sigma), sigma ~ 
gamma(shape, rate)}

\item{err_obs_iid_sigma_shape}{The shape parameter on a gamma distribution 
for err_obs_iid_sigma, the standard deviation of the observation error}

\item{err_obs_iid_sigma_rate}{The rate parameter on a gamma distribution for 
err_obs_iid_sigma, the standard deviation of the observation error}

\item{err_proc_acor_phi_shape}{The shape parameter on a gamma distribution 
for err_proc_acor_phi, the autocorrelation coefficient for the 
autocorrelated component of process [& sometimes observation] error}

\item{err_proc_acor_phi_rate}{The rate parameter on a gamma distribution for 
err_proc_acor_phi, the autocorrelation coefficient for the autocorrelated 
component of process [& sometimes observation] error}

\item{err_proc_acor_sigma_shape}{The shape parameter on a gamma distribution 
for err_proc_acor_sigma, the standard deviation of the autocorrelated 
component of process [& sometimes observation] error}

\item{err_proc_acor_sigma_rate}{The rate parameter on a gamma distribution 
for err_proc_acor_sigma, the standard deviation of the autocorrelated 
component of process [& sometimes observation] error}

\item{err_proc_iid_sigma_shape}{The shape parameter on a gamma distribution 
for err_proc_iid_sigma, the standard deviation of the uncorrelated (IID) 
component of process [& sometimes observation] error}

\item{err_proc_iid_sigma_rate}{The rate parameter on a gamma distribution for
err_proc_iid_sigma, the standard deviation of the uncorrelated (IID) 
component of process [& sometimes observation] error}

\item{priors}{logical. Should the data list be modified such that JAGS will 
return priors rather than posteriors?}

\item{params_out}{a character vector of parameters whose values in the MCMC 
runs should be recorded and summarized}

\item{n_chains}{the number of chains to run}

\item{n_cores}{the number of cores to apply to this run}

\item{adapt_steps}{the number of steps per chain to use in adapting the model}

\item{burnin_steps}{the number of steps per chain to run and ignore before
starting to collect MCMC 'data'}

\item{saved_steps}{the number of MCMC steps per chain to save}

\item{thin_steps}{the number of steps to move before saving another step. 1
means save all steps.}

\item{verbose}{logical. give status messages?}

\item{weights}{For Kmodel, character vector indicating the type of weighting 
to use. Set to c() for no weights. One of c("1/CI", "K600/CI", c()).}

\item{filters}{For Kmodel, named numeric vector of limits to use in filtering
data_daily. Elements may include
c("CI.max","discharge.daily.max","velocity.daily.max"). If an element is
given, the corresponding filter is applied: K600.upper-K600.lower <=
CI.max, discharge.daily <= discharge.daily.max, velocity.daily <= 
velocity.daily.max}

\item{predictors}{For Kmodel, character vector of variables (column names in 
data or data_daily) to use in predicting K. Leave blank or set to c() for 
no predictors. Otherwise, one or more of these may be included: c("date", 
"velocity.daily", "discharge.daily").}

\item{transforms}{For Kmodel, a named character vector of names of functions 
(probably 'log' or NA) to apply to K600 and/or the predictors. K600 should 
probably be logged. The vector names must match the values of 
\code{predictors}, although not all elements of \code{predictors} must be 
included in \code{transforms}. Recommended transforms include 
\code{c(K600='log', date=NA, velocity.daily="log", discharge.daily="log")}}

\item{other_args}{Other arguments passed to the fitting function given by 
\code{specs$engine}. \code{na.rm=TRUE} is already passed to 
\code{mean} (which is actually implemented as \code{sum}, anyway).}

\item{err.obs.sigma}{The sd of observation error, or 0 for no observation 
error. Observation errors are those applied to DO.mod after generating the 
full time series of modeled values.}

\item{err.obs.phi}{The autocorrelation coefficient of the observation errors,
or 0 for uncorrelated errors.}

\item{err.proc.sigma}{The sd of process error, or 0 for no process error. 
Process errors are applied at each time step, and therefore propagate into 
the next timestep.}

\item{err.proc.phi}{The autocorrelation coefficient of the process errors, or
0 for uncorrelated errors.}

\item{sim.seed}{NA to specify that each call to predict_DO should generate 
new values, or an integer, as in the \code{seed} argument to 
\code{\link{set.seed}}, specifying the seed to set before every execution 
of predict_DO}
}
\value{
an internally consistent list of arguments that may be passed to 
  \code{metab_bayes}, \code{metab_mle}, etc. as the \code{specs} argument
}
\description{
Generates an internally consistent list of model specifications that may be 
passed to \code{metab_bayes}, \code{metab_mle}, etc. via the \code{specs} 
argument. This help file gives the definitive list of all possible model 
specs, but only a subset of these are relevant to any given 
\code{model_name}. See the 'Relevant arguments' section below. Irrelevant 
arguments for the given \code{model_name} should not be explicitly passed 
into this function (but don't worry - we'll just stop and tell you if you 
make a mistake). Relevant arguments for the given \code{model_name} either 
have default values or do not (see Usage). Relevant arguments without a 
default should rarely be overridden, because their values will be determined 
based on other arguments. Relevant arguments that do have a default can, and 
often should, be overridden to tailor the model to your needs.
}
\section{Relevant arguments}{

  
  * metab_bayes: Always relevant: \code{model_name, engine, split_dates, 
  keep_mcmcs, day_start, day_end, day_tests, GPP_daily_mu, GPP_daily_sigma, 
  ER_daily_mu, ER_daily_sigma, priors, params_out, n_chains, n_cores, 
  burnin_steps, saved_steps, thin_steps, verbose}. The need for other 
  arguments depends on features of the model structure, as from 
  \code{mm_parse_name(model_name)}: If \code{$pool_K600=='none'} then 
  \code{K600_daily_mu, K600_daily_sigma}. If \code{$pool_K600=='normal'} then
  \code{K600_daily_mu_mu, K600_daily_mu_sigma, K600_daily_sigma_shape, 
  K600_daily_sigma_rate}. If \code{pool_K600=='linear'} then 
  \code{K600_daily_beta_mu, K600_daily_beta_sigma, K600_daily_sigma_shape, 
  K600_daily_sigma_rate}. If \code{pool_K600=='binned'} then 
  \code{K600_daily_beta_num, K600_daily_beta_cuts, K600_daily_beta_mu, 
  K600_daily_beta_sigma, K600_daily_sigma_shape, K600_daily_sigma_rate}. If 
  \code{err_obs_iid} then \code{err_obs_iid_sigma_shape, 
  err_obs_iid_sigma_rate}. If \code{err_proc_acor} then 
  \code{err_proc_acor_phi_shape, err_proc_acor_phi_rate, 
  err_proc_acor_sigma_shape, err_proc_acor_sigma_rate}. If 
  \code{err_proc_iid} then \code{err_proc_iid_sigma_shape, 
  err_proc_iid_sigma_rate}. If \code{engine == 'jags'} then 
  \code{adapt_steps}.
  
  * metab_mle: \code{model_name, day_start, day_end, day_tests, calc_DO_fun, 
  ODE_method, GPP_init, ER_init, K600_init}
  
  * metab_night: \code{model_name, day_start, day_end, day_tests}
  
  * metab_Kmodel: \code{model_name, engine, day_start, day_end, day_tests, 
  weights, filters, predictors, transforms, other_args}. Note that the 
  defaults for \code{weights}, \code{predictors}, \code{filters}, and 
  \code{transforms} are adjusted according to the \code{engine} implied by 
  \code{model_name}.
  
  * metab_sim: \code{model_name, day_start, day_end, day_tests, 
  err.obs.sigma, err.obs.phi, err.proc.sigma, err.proc.phi, ODE_method, 
  sim.seed}
}
\examples{
specs(mm_name(type='mle', err_obs_iid=FALSE, err_proc_iid=TRUE))
specs(mm_name(type='bayes', pool_K600='normal'))
}

